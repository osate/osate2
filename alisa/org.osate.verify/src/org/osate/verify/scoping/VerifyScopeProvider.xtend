/**
 * Copyright (c) 2004-2021 Carnegie Mellon University and others. (see Contributors file). 
 * All Rights Reserved.
 * 
 * NO WARRANTY. ALL MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY
 * KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE
 * OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT
 * MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
 * 
 * This program and the accompanying materials are made available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 * SPDX-License-Identifier: EPL-2.0
 * 
 * Created, in part, with funding and support from the United States Government. (see Acknowledgments file).
 * 
 * This program includes and/or can make use of certain third party source code, object code, documentation and other
 * files ("Third Party Software"). The Third Party Software that is used by this program is dependent upon your system
 * configuration. By using this program, You agree to comply with any and all relevant Third Party Software terms and
 * conditions contained in any such Third Party Software or separate license file distributed with such Third Party
 * Software. The parties who own the Third Party Software ("Third Party Licensors") are intended third party benefici-
 * aries to this license with respect to the terms applicable to their Third Party Software. Third Party Software li-
 * censes only apply to the Third Party Software and not any other portion of this program or this program as a whole.
 */

/*
 * generated by Xtext
 */
package org.osate.verify.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.SimpleScope
import org.eclipse.xtext.util.SimpleAttributeResolver
import org.osate.alisa.common.common.AVariableReference
import org.osate.alisa.common.scoping.CommonScopeProvider
import org.osate.verify.verify.Claim
import org.osate.verify.verify.VerificationActivity

import static org.osate.reqspec.util.ReqSpecUtilExtension.*
import static org.osate.verify.internal.util.VerifyUtilExtension.*
import org.eclipse.xtext.resource.EObjectDescription
import org.osate.reqspec.reqSpec.StakeholderGoals
import org.osate.reqspec.reqSpec.SystemRequirementSet
import org.osate.reqspec.reqSpec.ContractualElement

import static extension org.eclipse.xtext.EcoreUtil2.getContainerOfType

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 * 
 */
class VerifyScopeProvider extends CommonScopeProvider {

	def scope_ValDeclaration(VerificationActivity context, EReference reference) {
		val claim = getContainingClaim(context)
		var req = claim.requirement
		val result = scopeForGlobalVal(req,IScope.NULLSCOPE)
		return scopeForVal(req, result)
	}

	def scope_AVariableReference_variable(AVariableReference context, EReference reference) {
		val claim = getContainingClaim(context)
		var req = claim.requirement
		val result1 = scopeForGlobalVal(req,IScope.NULLSCOPE)
		val result2 = scopeForCompute(req, result1)
		return scopeForVal(req, result2)
	}

	def scope_ComputeDeclaration(VerificationActivity context, EReference reference) {
		val claim = getContainingClaim(context)
		var req = claim.requirement
//		val result = scopeForGlobalVal(req,IScope.NULLSCOPE)
		val result = IScope.NULLSCOPE
		return scopeForCompute(req, result)
	}

	def scope_Claim_requirement(Claim context, EReference reference) {
		var result = delegateGetScope(context, reference)
		val forSystemRequirements = (containingVerificationPlan(context)).getRequirementSet
		if (!forSystemRequirements.requirements.empty) {
			result = new SimpleScope(result,
				Scopes::scopedElementsFor(forSystemRequirements.requirements,
					QualifiedName::wrapper(SimpleAttributeResolver::NAME_RESOLVER)), false)
		}
		return result
	}


	def scope_VerificationActivity(EObject context, EReference reference) {
		val vas = getContainingClaim(context).activities
		new SimpleScope(IScope::NULLSCOPE, Scopes::scopedElementsFor(vas,
					QualifiedName::wrapper(SimpleAttributeResolver::NAME_RESOLVER)), false)
	}

	def scope_FormalParameter(EObject context, EReference reference) {
		val formalparams = getContainingVerificationMethod(context)?.formals
		new SimpleScope(IScope::NULLSCOPE, Scopes::scopedElementsFor(formalparams,
					QualifiedName::wrapper(SimpleAttributeResolver::NAME_RESOLVER)), false)
	}
	
		
	override IScope scope_AModelReference_modelElement(EObject context, EReference reference) {
		val claim = context.eContainer as Claim
		val contractualElement = claim.requirement
		val target = contractualElement?.targetElement ?:
				contractualElement?.target ?:
				contractualElement.getContainerOfType(SystemRequirementSet).target
		new SimpleScope(#[EObjectDescription.create("this", target)])
	}
	
}
